// updated 5-22-07/*	this function is the first part of the 	Knuth-Morris-Pratt algorithm.  It sends the		kansas repeat to the nextTable function.	If all the letters in the k.r. match the sequence, 	it moves to the eureka function*/function match($findthisStr, $inthisStr, $pseudoname) {	//	split into array	var $inthis=$inthisStr.split('');	//	keeps the snippets from being less than 8aa	var $llong=$findthisStr.length-7;	var $section=new Array();	//	brute force compare snippets to $inthis	for ($tick=0; $tick<$llong; $tick++) {		//	extracts 8aa snippets to compare to inthis		var $bracket=$findthisStr.substr($tick, 8);		var $snippet=$bracket.split('');		var $step=nextTable($snippet);		//	i and j for match tables, k for filling section array		var $i=0;		var $j=0;		while ($j<$inthis.length) {			while (($i>-1)&&($snippet[$i]!=$inthis[$j])) {				$i=$step[$i];			}			$i++;			$j++;			//	if snippet matches sequence, push onto end of $section			if ($i>=8) {				var $found=$j-$i;				$i=$step[$i];				$section.push($found);			}		}	}//	bookends the stretches of aa in sequence that match pseudogenes	var $gotcha=new Array();	if($section[0]!=undefined) {		for ($m=0; $m<$section.length; $m++) {			var $nextkey=$m+1;			var $nextvalue=$section[$m]+1;			if (($section[$nextkey])!=($nextvalue)) {				//	adds start aa of matching sequence to array, else for other matches				//	gotcha array hasn't been populated				if ($gotcha[0]==undefined) {					//	end of section array					if ($section[$nextkey]==undefined) {						var $tail=$inthisStr.length-7;						//	complete match						if ($nextvalue==$tail) {							$gotcha.push(0, $inthisStr.length);						//	front part matches, tail part doesn't						} else {							// alert($pseudoname+' '+$section[$m]+' '+$nextvalue+' '+$inthisStr.length);							//$gotcha.push(0, $section[$m], $nextvalue, $inthisStr.length);							$gotcha.push(0, $section[$m], $nextvalue);						}					//	section has more than one item					} else {						$gotcha.push($section[0], $section[$m], $section[$nextkey]);					}				//	gotcha has at least one item				} else {					//	end of section array					if ($section[$nextkey]==undefined) {						$gotcha.push($section[$m]);					//	at least one more item in section					} else {						$gotcha.push($section[$m], $section[$nextkey]);					}				}			}		}	}	//	sends to eureka, then sends results to mystery function 	var $foundsomething=eureka($gotcha, $inthisStr, $pseudoname);	return $foundsomething;}/*	this is the second half of the KMP algorithm	which figures how far back to set the k.r. 	when it encounters a mismatch.  It's different	for every repeat*/function nextTable($x) {	var $p=0;	var $q=-1;	var $next=new Array();	$next[0]=-1;	while ($p<$x.length) {		while (($q>-1)&&($x[$p]!=$x[$q])) {			$q=$next[$q];		}		$p++;		$q++;		if ($x[$p]==$x[$q]) {			$next[$p]=$next[$q];		} else {			$next[$p]=$q;		}	}	return $next;}/*	takes positions found to match and constructs a substring	from the enterd sequence, then stitches matches with junk	seqeunces to recreate original*/function eureka($discovery, $sequence, $namepseudo) {	$stitch=new Array();	$gotpseudo=$namepseudo+'::';	$stitch.push($gotpseudo);	//	no match, no items	if (isNaN($discovery[0])) {//alert($namepseudo+' '+'no match');		$nomatch=replaceWdash($sequence);		$stitch.push($nomatch);	} else {		//	sequence starts with junk		if ($discovery[0]!='0') {			//	tail matches, head doesn't			if ($discovery[1]==$sequence.length) {//alert($namepseudo+' '+'junk tail match');				var $headnon=$sequence.substring(0, $discovery[0]);				var $dashhead=replaceWdash($headnon);				var $tailmatch=$sequence.substring($discovery[0], $discovery[1]);				var $fancytail="<span class='hits'>"+$tailmatch.toUpperCase()+"</span>";				$stitch.push($dashhead, $fancytail);			//	junk match mix			} else {//alert($namepseudo+' '+'junk match mix');				for ($jm=0; $jm<=$discovery.length; $jm++) {					//	first stretch of junk					if ($jm==0) {						var $junk1=$sequence.substring(0, $discovery[0]);						var $dashjunk1=replaceWdash($junk1);						$stitch.push($dashjunk1);						//alert($namepseudo+' '+$jm+' '+$discovery[0]);					} else {						//	when jm is even, that's the end of a stretch of junk						if (($jm/2)==(parseInt($jm/2))) {							//	if jm is NaN, that's past the end of the discovery array							if (isNaN($discovery[$jm])) {								//	compensate for the snippet length								var $discoJF=($discovery[($jm-1)])+7;								var $discoJE=$sequence.length-1;								var $junkIBT=$sequence.substring($discoJF, $discoJE);								var $dashjunkIBT=replaceWdash($junkIBT);								$stitch.push($dashjunkIBT);							//	regular end of junk							} else {								//	compensate for the snippet length								var $discoJF=($discovery[($jm-1)])+7;								var $discoJE=($discovery[$jm])-1;								var $junkIBT=$sequence.substring($discoJF, $discoJE);								var $dashjunkIBT=replaceWdash($junkIBT);								$stitch.push($dashjunkIBT);							}							//alert($namepseudo+' '+$jm+' '+$discoJF+' '+$discoJE);						//	if jm is odd, that's the start of a strech of match						} else {							var $discoF=$discovery[($jm-1)];							//	compensate for the snippet length							var $discoEp=$discovery[$jm]+8;							var $goods1=$sequence.substring($discoF, $discoEp);							var $fancygoods1="<span class='hits'>"+$goods1.toUpperCase()+"</span>";							$stitch.push($fancygoods1);							//alert($namepseudo+' '+$jm+' '+$discoF+' '+$discovery[$jm]);							//alert($namepseudo+' '+$discovery[($jm-1)]+' '+$discovery[$jm]);						}					}				}				// alert($namepseudo+' '+$discovery[1]+' '+$discovery.length+' '+$sequence.length);			}		//	sequence starts with match		} else {			//	total match			if ($discovery[1]==$sequence.length) {//alert($namepseudo+' '+'total match');				$totalmatch="<span class='hits'>"+$sequence.toUpperCase()+"</span>";				$stitch.push($totalmatch);			} else {				//	head matches, but tail doesn't				if ($discovery.length==3) {					//	compensate for snippet					var $headP=$discovery[1]+8;					var $headmatch=$sequence.substring($discovery[0], $headP);					var $fancyhead="<span class='hits'>"+$headmatch.toUpperCase()+"</span>";					var $tailnon=$sequence.substring($headP, $sequence.length);					var $dashtail=replaceWdash($tailnon);					$stitch.push($fancyhead, $dashtail);				} else {							//	match junk mix					for ($mj=0; $mj<=$discovery.length; $mj++) {						//	match stretch						if ($mj==0) {												//	compenstate for snippet							var $firstend=($discovery[1])+8;							var $firstmatch=$sequence.substring(0, $firstend);							var $fancy1match="<span class='hits'>"+$firstmatch.toUpperCase()+"</span>";							$stitch.push($fancy1match);						} else {							//	if even, its a match							if (($mj/2)==(parseInt($mj/2))) {								var $matchEnd=$discovery[($mj+1)]+8;								var $match2=$sequence.substring($discovery[$mj], $matchEnd);								var $fancymatch2="<span class='hits'>"+$match2.toUpperCase()+"</span>";								$stitch.push($fancymatch2);							} else {								//	starts a stretch of junk								if ($mj==1) {									var $end1junk=$discovery[($mj+1)]-7;									var $start1junk=$discovery[$mj]+1;									var $firstjunk=$sequence.substring($start1junk, $end1junk);									var $dash1junk=replaceWdash($firstjunk);									$stitch.push($dash1junk);								} else {									if (($discovery[$mj]+8)!=$sequence.length) {										var $oddjunkS=$discovery[$mj]+7;										var $oddjunkE=$discovery[($mj+1)]-1;																				if (isNaN($oddjunkE)) {											var $oddstretch=$sequence.substring($oddjunkS, ($sequence.length-1));											var $odddash=replaceWdash($oddstretch);											$stitch.push($odddash);										} else {											var $oddstretch=$sequence.substring($oddjunkS, $oddjunkE);											var $odddash=replaceWdash($oddstretch);											$stitch.push($odddash);										}									} else {										//alert('end');									}								}							}						}					}					}			}		}	}	//	joins all the pieces together and sends back to match	var $sew=$stitch.join('');	return $sew;}/*	replaces string with dashes*/function replaceWdash($letters) {	var $dash="";	for ($dl=1; $dl<=$letters.length; $dl++) {			$dash+="-";	}	return $dash;}/*	takes each pseudogene and cranks it through match function	each string result is pushed onto the end of $foundpseudo, 	then sends array to finsihed function*/function mystery() {	var $pseudo=new Array();		$pseudo[0]=Array('1:::','pyqgyhsmltalegsigysiggarvevevgyerfvikggkksnedtasvfllgkelaydtargqvdrlatalgkmtkseakkwgnaiesatgttsgdelskkvcgkgttsgnqcgvnatsgstnngklstvfntdgaeaissmdttasgtsntislqgmagninslflltqrhgcshtflsfalpythiinrawvdalveeg');	$pseudo[1]=Array('2:::','pyqgyhsmltalegsigysiggarvevevgyerfvikggkksnedtasvfllgkelaydtargqvdrlatalgkmtkseakkwgnaiesatgttsgdelskkvcgkgegsngtkkcgttdstattkisevftegtdtllsvegnkdtinlqgmanninnlskedkavvagafaravegaescgelg');	$pseudo[2]=Array('9h1:','pyttnitiaghaslpniaimlepkisfkdsmltalegsigysiggarvevevgyerfvikggkksnedtasvfllgkelaydtargqvdrlaaalgkmtkseakkwgnaiesatgttngekvsqkvcgngtgssgtqcgknsgdtngssttqhkisavftdeatllsaagdtinttgmagninsltkdekaivagafaravegaevievraigstsvmlnpgittlptqpkllvpplhlavpnadtpaisknlsfgiitvlprnithtsnllprspst');	$pseudo[3]=Array('e6f7','pyqgyhsmltalegsigysiggarvevevgyerfvikggkksnedtasvfllgkelaydtargqvdrlaaalgkmtkgeakkwgttveaatngqtvsqkvcgngtgssgsncgknttdstnnngkitqaftadsdttllsaessnistsgmatninglskeekavvagafaravegaescggglgrr');	$pseudo[4]=Array('p1e6','hrnrhcyrsgrevgarvevgigherfvikggkksnedtasvfllgkelaydtargqvdrlatalgkmtkgeakkwgnavenatngdkvsqnvckgtgstgssgnkcgttdstattkisavftedaaaqlstmdnttinttgmanninslskedkavvaravlagltlaalvrsvsdvarksgeshccrrg');	// 3h1 and 2 are the same	// $pseudo[5]=Array('3h1:','pyqgyhsmltalegsigysiggarvevevgyerfvikggkksnedtasvfllgkelaydtargqvdrlatalgkmtkseakkwgnaiesatgttsgdelskkvcgkgegsngtkkcgttdstattkisevftegtdtllsvegnkdtinlqgmanninnlskedkavvagafaravegaescgelg');	// $pseudo[6]=Array('sgv1','targqvdrlatalgkmtkseakkwgnaiesatgttsgdelskkvcgkgttsgnqcgknsgdtngssttqhkisavftdeatllsaagdtinttgmagninsltkdekaivagafara');	// $pseudo[7]=Array('sgv2','targqvdrlatalgkmtkgeakkwgnavenatngdkvsqnvckgtgstgssgnkcgttdstattkisavftedaaaqlstmdnttinttgmanninsltkdekaivagafara');	//	convert aa sequence to lower case	var $seqRaw=document.repeat.aminoacids.value;	//	scrubs out dashes found in aligned seqeunce files	var $seqdashed=$seqRaw.split('-');	var $dropedashes=$seqdashed.join('')	var $seq=$dropedashes.toLowerCase();	var $ratchet=0;	var $foundpseudo=new Array();	while ($ratchet<$pseudo.length) {		var $looking=match($pseudo[$ratchet][1], $seq, $pseudo[$ratchet][0]);		$foundpseudo.push($looking);		$ratchet++;	}	$orig="orig::"+$seq.toUpperCase();	$foundpseudo.push($orig);	finished($foundpseudo);	delete $foundpseudo;}/*	opens new window, writes the match results found in match function*/function finished($hereitis) {	$whichone=document.repeat.handle.value;$results=window.open('','thend','left=50px,top=70px,width=900,height=500,toolbar=1,scrollbars=1,resizable=1');	$results.document.write("<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'><html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'><head><title>msp2 results</title><link rel='stylesheet' type='text/css' href='msp2style.css' media='screen' /><link rel='stylesheet' type='text/css' href='msp2printstyle.css' media='print' /></head><body id='display'><div id='containresults'><h2>&#966;genes found in "+$whichone+"</h2>");	//$results.document.write("<ul>");	for ($dd=0; $dd<$hereitis.length; $dd++) {		$strung='<p>'+$hereitis[$dd]+'</p>';		$results.document.write($strung);	}	$results.document.write("</div></body></html>");	$results.document.close();}// clears the input boxfunction erase() {	document.repeat.aminoacids.value="";		document.repeat.handle.value="";	document.repeat.aminoacids.focus();}